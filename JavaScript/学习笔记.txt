待实现的功能：

1.数据交互（提交表单与链接数据库并展示数据）
2.样式完善
①下拉表格时表头浮动 
②
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

spring 学习笔记

创建新项目需要先执行4个步骤：
1. 
生成web.xml文件；

2. 
添加依赖：在此前的项目中找到pom.xml，将其中的依赖的代码复制到当前项目中，关于依赖的jar包，会越用越多，学习时，只加不减；

3. 
复制spring.xml文件到当前项目中，并删除其中的配置，除非你确定这些配置是当前项目中必须使用的；

4. 
为项目添加Tomcat运行环境；
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Json学习笔记

解析数据 Json.parse(text,reviver) -reviver参数
例如对日期Date的解析(JSON 不能存储 Date 对象):
var text = '{ "name":"Runoob", "initDate":"2013-12-14", "site":"www.runoob.com"}';
var obj = JSON.parse(text, function (key, value) {
	if (key == "initDate") {
	    return new Date(value);
	} else {
	    return value;
}});

解析函数eval()
可以先得到转换的JavaScript对象,再对函数属性用eval()转换:
var text = '{ "name":"Runoob", "alexa":"function () {return 10000;}", "site":"www.runoob.com"}';
var obj = JSON.parse(text);
obj.alexa = eval("(" + obj.alexa + ")");
也可以套用解析数据一次转换到位:
var text = '{ "name":"Runoob", "alexa":"function () {return 10000;}", "site":"www.runoob.com"}';
var obj = JSON.parse(text,function(key,value){
	if(key=="alexa"){
	   return eval("("+value+")")
	}else{
	   return value;
}});

转换好的函数即为obj.alexa();
思考:传函数有必要吗?简单独立的函可能可以传,复杂的传过去用得了吗?而且实际上既然是使用字符串来伪存储函数,那么何不直接传完整代码,传算法及说明文档呢?=>没有考虑 js 里函数也是数据类型。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

在互联网应用开发领域，授权所用到的授信媒介主要包括如下几种：

通过web服务器的session机制，一个访问会话保持着用户的授权信息
通过web浏览器的cookie机制，一个网站的cookie保持着用户的授权信息
颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息
前面两者常见于web开发，需要有浏览器的支持
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

权限与控制

权限就是一个[能被识别和认定][角色关于资源][操作行为]的消息（通常这个消息存于载体--废话）
控制就是一个[依据权限][监督角色][对资源操作]的机制
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

注解 @RestControllerAdvice 介绍

在spring 3.2中，新增了@ControllerAdvice 注解，可以用于定义@ExceptionHandler、@InitBinder、@ModelAttribute，并应用到所有@RequestMapping中。
如果全部异常处理返回json，那么可以使用 @RestControllerAdvice 代替 @ControllerAdvice ，这样在方法上就可以不需要添加 @ResponseBody。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

RBAC（Role-Based Access Control）权限模型的概念，即：基于角色的权限控制。
通过角色关联用户，角色关联权限的方式间接赋予用户权限。
RBAC 还可以指（Role-Based Access Control）基于资源的权限控制。这种模型权限粒度更细。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

MVC - 模型视图控制器体系结构（版本4）

MVVM - 模型视图Viewmodel（版本5）
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

仓库(repository)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ctr+f 可以在记事本里查找内容
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

session 会话
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

关于文件与流操作的对象

FileOutputStream fileOutputStream  = new FileOutputStream("temp.o");//fileName.type
ObjectOutput objectOutputStream = new ObjectOutputStream(fileOutputStream);
objectOutputStream.writeObject(class);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Serializable 序列化

>WHAT?	
	]1.序列化：将对象状态转化为可保持或可传输的格式的过程。与序列化相对应的是反序列化，它将流转换为对象。
	]2.Serializable 接口：一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化。
>WHY?	
	]1.为什么序列化：将序列化和反序列化两个过程结合起来，可以轻松地存储和传输数据。当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化以便将来使用时，都需要把对象进行序列化。
	]2.为什么继承 Serializable：表明其是存储对象，在存储介质中，以便在下次使用的时候，可以很快捷的重建一个副本。
>WHEN?
	]1.何时要将状态信息持久化？存储媒界（如数据库等）里面，没有其包含的数据结构时；
	]2.何时需要远程传输？发生两个不同系统甚至是分布式模块之间的调用时。
>HOW?	
	]1.实现（implement）Serializable 接口；
	]2.声名一个 serialVersionUID 变量（无，则会默认生成，强烈建议自行声明）。
>MORE?	
	-空接口，是一个标识接口，通知 jvm 帮实现 Serializable 的对象序列化
	-Serializable 接口就是 Java 提供用来进行高效率的异地共享实例对象的机制，实现这个接口即可。
	-序列化过程可能涉及到其他对象的引用，引用的对象的相关信息也要参与序列化。
	-JVM（Java Virtual Machine，Java 虚拟机）用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。
	-serialVersionUID 辅助对象的序列化与反序列化,判断反序列化是否成功。
	-序列化/反序列化演示（主要学习文件与流操作的对象）
		//序列化
		FileOutputStream fileOutputStream  = new FileOutputStream		("temp.o");//fileName.type，还可以指定文件路径
		ObjectOutput objectOutputStream = new ObjectOutputStream(fileOutputStream);
		objectOutputStream.writeObject(serializableClass);//实现 Serializable 的类
		objectOutputStream.close(); 
		//反序列化
		FileInputStream fileInputStream = new FileInputStream("temp.o");
        		ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
       		SerializableClass sc = (serializableClass)  objectInputStream.readObject();
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


最近访问文件	ctr+e
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

comment 注释\annotation 注解
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

@link 注解作用的理解：就是为了让注释中表示类的代码生效（不被注释，又不产生副作用），接着就能使用 IDE 提供的查找源码的方法找到源码了。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

WebSocket 介绍	

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

MVVM(Model-View-ViewModel) 是一种视图和数据模型双向绑定的框架，它将 MVC 中 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SPA 介绍

SPA（single page web application），单页面应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在单页应用中，所有必要的代码（ HTML、JavaScript 和 CSS ）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面。SPA 有一个缺点，因为 SPA 应用部署后只有1个页面，而且这个页面只是一堆 js 、css 引用，没有其他有效价值，因此，SPA 应用不易被搜索引擎收录，所以，一般来说，SPA 适合做大型企业后台管理系统。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Vue 项目结构介绍

总目录
-build 文件夹，用来存放项目构建脚本
-config 中存放项目的一些基本配置信息，最常用的就是端口转发
-node_modules 这个目录存放的是项目的所有依赖，即 npm install 命令下载下来的文件
-src 这个目录下存放项目的源码，即开发者写的代码放在这里
-static 用来存放静态资源
-index.html 则是项目的首页，入口页，也是整个项目唯一的 HTML 页面
-package.json 中定义了项目的所有依赖，包括开发时依赖和发布时依赖

src 目录
-assets 目录用来存放资产文件
-components 目录用来存放组件（一些可复用，非独立的页面），当然开发者也可以在 components 中直接创建完整页面。推荐在 components 中存放组件，另外单独新建一个 page 文件夹，专门用来放完整页面。
-router 目录中，存放了路由的js文件
-App.vue 是一个Vue组件，也是项目的第一个Vue组件
-main.j s相当于 Java中 的 main 方法，是整个项目的入口 js

main 解析
-在 main.js 中，首先导入 Vue 对象
-导入 App.vue ，并且命名为 App
-导入 router，注意，由于 router 目录下路由默认文件名为 index.js ，因此可以省略
-所有东西都导入成功后，创建一个 Vue 对象，设置要被 Vue 处理的节点是 '#app'，'#app' 指提前在index.html 文件中定义的一个div
-将 router 设置到 vue 对象中，这里是一个简化的写法，完整的写法是 router:router，如果 key/value 一模一样，则可以简写。
-声明一个组件 App，App 这个组件在一开始已经导入到项目中了，但是直接导入的组件无法直接使用，必须要声明。
-template 中定义了页面模板，即将 App 组件中的内容渲染到 '#app' 这个 div 中。

传送门：https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247485303&idx=1&sn=0b04836496f2d22dd2dcb116041570e7&scene=21#wechat_redirect
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

DO、PO、BO、DTO、VO 等初步概念

-POJO
全称为：Plain Ordinary Java Object，普通的 java 对象，一般用在数据层映射到数据库表的类，类的属性与表字段一一对应

-PO
全称为：Persistant Object，持久化对象，与数据库结构映射的实体，数据库中的一条数据即为一个 BO 对象

-BO
全称为：Business Object，业务对象，主要作用是把业务逻辑封装成一个对象，这个对象可以包括一个或多个其它对象，比如一个简历 BO 中有教育经历，工作经历，社会关系等 PO 对象

-DTO
全称为：Data Transfer Object，数据传输对象，比如一张表有 100 个字段，那么对应的 PO 就有100 个属性（大多数情况下，DTO内部的数据结构来自多个表）但 view 层只需要显示 10 个字段，没有必要把整个 PO 对象传递到 client，这时我们就可以用只有这 10 个属性的 DTO 来传输给 client，这样也不会暴露 server 端表结构，到达客户端后，如果这个对象来对应页面显示，它的身份就转为 VO

-VO
全称为：View Object，主要对应页面展示的数据对象，一般继承自 PO，可以添加 PO 中没有的字段，用来逻辑处理以及其它消息存储

-DO
全称为：Domain Object，领域对象，从现实世界中抽象出的业务实体，一般还包含 ORM 映射

-DAO
全称为：Data Access Object，数据访问对象，一般所说的 DAO 层，用于连接数据库与外层之间的桥梁，并持久化数据层对象

-JavaBean
JavaBean 是一种 Java 语言写成的可重用组建，它的规范必须符合特定的约定：
・这个类必须有一个公共的缺省构造函数
・这个类的属性用 getter 和 setter 访问
・这个类可被序列化

模型
・用户发出请求，表单的数据层被匹配为 VO
・展示层把 VO 转换为服务层对应方法锁要求的 DTO，传输给服务层
・服务层首先根据 DTO 的数据构造一个 DO，调用 DO 的业务方法完成具体业务
・服务层把 DO 转换为持久层对应的 PO，调用持久层持久化方法，把 PO 传递给它完成持久化操作

传送门：https://www.jianshu.com/p/1832575fd79e
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 export default

-用法：相当于提供一个接口给外界，让其他文件通过 import 来引入使用。
-export default 和export的区别:
  在JavaScript ES6中，export与export default均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用，但在一个文件或模块中，export、import可以有多个，export default仅有一个。 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

reverse 反转；颠倒 \ reserve 储备；保留；拥有
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JavaScript 里逻辑运算的返回值（这与 Java 甚至其他目前了解到的语法全然不同）

逻辑与运算（“&&”运算）会返回最早遇到非以下类型的值：
NaN null undefined 0 false;
逻辑或运算（“||”运算） 会返回最早遇到非以下类型的值：
NaN null undefined 0 false;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JavaScript 学习笔记

-数据类型
 JavaScript六种基本类型有：number string Boolean undefined null object。
 其中，object可细分为三个子类型：狭义object、array和function。

-逻辑运算的返回值（这与 Java 甚至其他目前了解到的语法全然不同）
 1.逻辑与运算（“&&”运算）会返回最早遇到非以下类型的值：
 NaN null undefined 0 false;
 2.逻辑或运算（“||”运算） 会返回最早遇到非以下类型的值：
 NaN null undefined 0 false;

-"="相关运算符
 值表达式（=）、严格相等运算符（===）和相等运算符（==），后两个的区别是:（==）会做类型转换。

-label 标签
 语句的前面写标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。
 label:
   语句

-undefined 与 null 的区别
 ”没有定义“和”定义没有“的区别。

-parseInt/parseFloat 转换函数
 作用：将字符串转成整数/浮点数
 例子：
 parseInt('123');(===parseInt(123);===parseInt(String(123))
 parseInt('0xff');（只有十六进制支持该写法）(===parseInt('ff',16);第二个可选参数指定输入字符的进制，范围在2~32)
 parseInt(0o377);(非十六进制可利用该写法）(===parseInt(String(0o377));===parseInt('255');===parseInt('377',18))
 易错：parseInt(011,2);预期：3，结果：NaN。(===parseInt('9',2);)

-原生Basement4转码函数
 编码：btoa()
 解码：atob()
 示例：
 btoa('hello');(结果："aGVsbG8=";某些字符串编码出来的字符码末尾会有’=‘或’==‘的情况，这些字符码解码时它们可有可无)
 atob('aGVsbG8=');(结果："hello";atob('aGVsbG8');也行。）
 另外，如要对含有汉字的字符串编码，还需以下转换：
 function b64Encode(str) {
   return btoa(encodeURIComponent(str));
 }
 function b64Decode(str) {
   return decodeURIComponent(atob(str));
 }
 示例：
 b64Encode('我爱你');（结果："JUU2JTg4JTkxJUU3JTg4JUIxJUU0JUJEJUEw"）
 b64Decode('JUU2JTg4JTkxJUU3JTg4JUIxJUU0JUJEJUEw');（结果：”我爱你“）

-链式引用
 说明：属性的值还是一个对象，就形成了链式引用。
 var o1 = {};
 var o2 = { bar: 'hello' };
 o1.foo = o2;//这里属性是动态创建的
 o1.foo.bar; // "hello"

-eval语句
 作用：对字符串求值
 示例：（示例同时还用于展示另一个知识点：外加()以区分{}是代码块还是对象声明的表达式）
  eval('{foo: 123}'); // 123
  eval('({foo: 123})'); // {foo: 123}

-匿名函数 anonymous funtion() 与构造函数 constructor Function()
 匿名函数又称函数表达式（Function Expression），声明方式：
 var funA=function(params){...};
 构造函数声明方式：
 var funC=new Function('param1','param2',...,'paramN','functionBody');
 另外，匿名函数可以有名字，该参数名只能在函数体内部访问，可用以声明递函数
 示例：（斐波那契数列）
  var fib=function fibInner(num){
      if(num===0)return 0;
      if(num===1)return 1;
      return fibInner(num-2)+fibInner(num-1);
  };
  fibInner(6); //ReferenceError: fibInner is not defined
  fib(6); //8

-闭包函数初步理解
 // 定义闭包函数，形成闭包环境
 function closureFun(initParam){ // 勘误：闭包不是指父函数，而是指内嵌子函数
     var innerProp='父函数内部私有属性';
     function innerFun(innerParam){ // 必须嵌套有内部函数
         console.log(innerProp);
         console.log(initParam);
         console.log(innerParam);
         return innerParam;
     }
     return innerFun; // 必须返回内部函数
 }
 // 创建变量接收闭包函数实例的返回值
 var otherFun=closureFun('初始化参数'); 
 // 该变量实质是内部函数的引用，所以不妨直接称它为外部函数
 otherFun;
 /* 结果：
  *  innerFun(innerParam){
  *        console.log(innerProp);
  *        console.log(initParam);
  *        console.log(innerParam);
  *        return innerParam;
  *  }
    */
 // 外部函数实例化，使得闭包环境得以维护，从而可以访问到“父函数内部私有属性”和“初始化参数”
 otherFun('内部参数（普通参数）')
 /* 结果：
  *  父函数内部私有属性
  *  初始化参数
  *  内部参数（普通参数）
  *  "内部参数（普通参数）"
    */


-普通变量与函数（变量）使用的区别
 普通变量的使用模式是：声明->赋值->引用；
 函数（变量）的使用模式是：声明->定义->引用->实例；
（引用和实例的外在区别体现在有无“()”，内在就是“形”与“值”的区别。java 里原本没有“引用”这一环，而只有与“实例”对应的“调用”，不过不清楚 java8 lambda 表达式是否已支持）
 补充：java 中不支持函数内部定义内嵌函数，只可以内嵌函数自身，构成递归函数。另外，函数参数也不支持“函数类型”，因为基本数据类型中根本就没有函数类型。

-函数参数传递类型
 1.基本类型参数为值传递（passes by value），或称参数为值类型
 2.类类型参数为址传递（pass by reference），或称参数为引用类型

-函数的 length 属性
 返回函数预期传入的参数

-立即调用的函数表达式（IIFE）
 目的：对匿名函数使用这种“立即执行的函数表达式”，不必为函数命名，避免了污染全局变量；封装产生作用域，封装私有变量
 做法：给函数外加“()”使之成为函数表达式。（还有其他方式，这是标准方式）
 例子：
  function(){}() // 报错，function 在行首被当做语句，语句不应以“()”结尾
  var f = function(){console.log('函作为表达式')}(); // function 作为表达式，可以被立即执行
  (function(){console.log('函数作为表达式')}()); // 同样被立即执行,注意两个连续 IIFE 表达式之间必须用‘;’分开，避免第二个被当做第一个的参数而出错。
  (function(){console.log('函数作为表达式')})(); // 同上面等价

-eval 命令 （不要用）
 作用：接受一个字符串作为参数，并将这个字符串当作语句执行。常用来解析 JSON 数据的字符串（但最好用原生的 JSON.parse 方法代替）。
 例子：
  eval('console.log("lol")')
 注意：非字符串原样返回；非语句参数会报错；语句也应有单独存在的意义；其他语句应满足语句的基本规则；无私有作用域、别名调用产生的影响等。
 反例：
  eval(121); // 非字符串原样返回
  eval('3x'); // 非语句
  eval('return;'); // return 不单独，
  eval('var foo="eval里的语句没有自己的作用域，等同于直接嵌入的语句"') // strict 模式会给它赋予作用域，这有利于开发。

-数组
 目的：数据结构需要（性能需要其它语言才涉及）。
 概念：数组是有序的对象集。（强类型语言的基本类型数组还要求元素类型一致，创建时指定数组长度（此后数组长度不变））
 特点；JavaScript 数组的类型是对象。数组元素索引可以不连续。数组长度可以赋值。
 使用：
  声明+初始化：var arr = ['str',6,{foo:'对象也可以'},['另一个数组'],,]; // ‘,,’表示留有空位 empty。空位不会被 forEach 等所遍历，因为它们没有索引。
  添加元素：1. arr.push('末尾添加','可以有多个参数','按参数顺序依次添加'); // 返回数组长度
			2. arr.unshift; // 添加首元素。
  删除元素：1. arr.pop(); // 删除尾元素，返回删除元素，空位也会被删除，并返回 undefined。
  			2. arr.shift(); // 删除首元素。
    修改元素：arr[33]='数字索引会被转换成字符串'; // 若元素本不存在则会变成添加。33号元素之前可以有未定义的元素，会被标识为 empty 空位。
    添加属性（不建议）：a[-1]='数组是对象就可以添加属性'; // 添加了‘-1’属性。要与添加元素相区分，最好避免数字名属性，或使用‘.’的形式添加。数组添加的属性将不被 hasOwnProperty() 检测到。
    length 属性：arr.length // 返回已定义的元素最大索引+1（相当于承认中间未定义的元素对数组长度有影响，但不予保存）。
			   arr.length= Math.pow(2, 32)-1; // 可以赋值，但不得超过2^32-1，更不能赋其它不合理的值或类型
    删除数组：1. arr.length=0; // 那么不难想到，可以批量删除元素，而类数组无法这么做。
            2. arr=undefined // 赋 undefined 值
      遍历：1. for\while 循环（同 java）
		2. forEach() 方式
		 arr.forEach(function(item){console.log(item)});
	    3. for-in 方式
	
		 for(var i in arr){console.log(i)}; // 会把对象属性也遍历出来，所以慎用

-类数组对象
 目的：JavaScript 字符串和部分内置对象就属于该类型。内置对象如函数的 arguments 对象
 特点：一个对象的所有键名都是正整数或零，并且有length属性。
 slice 方法：slice 根据索引找出选定区间的元素，返回目标数组。
 例子：'abc'.slice(0,1) // [a,b] 
	   Array.prototype.slice.call('abc') // ["a","b","c"]，转换成了数组

-输出一个字符串里的四字节字符
 String.fromCharCode('??'.charCodeAt(0),'??'.charCodeAt(1)); // '??'

-true 和 false 与其他类型的
 false：六种类型代表值：undefined,null,0,false,NaN,''；
 true：上面六种类型取反；任何对象（包括 new Boolean() 包装出来的值为 false 的对象）。
 另外能直接与 false 或 true 以“==”做等价转化的只有： 
 true：1、'1'、[1]，
 false：0、‘’、[0]
 原因在于类型转化优先级。
 另外有一个奇怪的现象：[]==![] 为 true，难道它们做的是址比较？可是 [1]==![1]、['1']==!['1'] 的结果却是 false。
 进一步解释：
 “==”类型转换规则:
 值类型 == 值类型 //相当于 Number(值类型) == Number(值类型)
 引用类型 == 引用类型 // 直接比较引用地址
 引用类型 == 值类型 // 将引用类型对象转化成原始类型的值，再进行比较
 比较规则：对象
 与数值进行比较，会先转成数值，再进行比较；
           与字符串进行比较，会先转成字符串，再进行比较；
		   与布尔值进行比较，两个运算子都会先转成数值，然后再进行比较。

-与字符串的加法运算会被重载
 1+'a' // '1a'
 true+'a' // 'truea' 
 1+'2'+3 // '123'
 1+2+3 // '33'

-运算副作用
 概念：运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。
 例子：x++; // 运算符里只有自增/减是负相应的

-数值运算符“+/-”
 目的：可以将任何值转为数值
 例子：
  +true; // 1
  -[]; // -0

-指数运算符“**”
 例子：2**3**2; // 可嵌套，相当于2**(3**2)但嵌套不了几层就超出可表示的数值范围了。

-判断奇偶
 1&Number; // 奇数1，偶数0

-console 有用\有趣的静态方法
 例子；
  1. log\info 带 css 样式的信息
    console.info('%c控制台打印信息可以有 css 样式！',
	'color: red; background: yellow; font-size: 24px;');
  2. table 输出复合对象表格
    var family =[

    { relationship:'爸爸',name:'xxx'},
    { relationship:'妈妈',name:'xxx'},
    { relationship:'姐姐',name:'xxx'},
  ];
  console.table(family); // 数组
  var family ={
    father:{ name:'xxx',age:100},
    mother:{ name:'xxx',age:100},
    sister:{ name:'xxx',age:18},
  };
  console.table(family); // 对象
  3. dir 查看 DOM
    console.dir(document.body); // 输出网页 DOM
    console.log(document.body); // 输出了整个 element 选项

-属性描述对象（attributes object）
 目的：提供了一个内部数据结构，用来描述对象的属性，控制它的行为，又称元属性对象，以下简称元属性。
 例子：
  // 用 definePropertie\defineProperties 方法定义元属性。
  var obj=Object.definePropertie({},'foo',{
	value: undefined, // 属性的属性值	
	writable: true, // 属性值是否可写
	enumerable: true, // 是否可遍历
	configurable: true, // 元属性是否可写（不包括 value）
	//get: undefined, // 取值函数，不能和 value 同时设置或同时设置 writable 为 true 。
	//set: undefined // 存值函数，规则同上。
  });
  Object.getOwnPropertyDescriptor(obj,'foo'); // 返回参数指定的元属性
  补充：defineProperty\definePropertys 的使用方法
   函数原型：
    1. Object.defineProperty(object, propertyName, attributesObject);
    参数说明：参数依次为，属性所在的对象、属性名字符串、元属性。
    2. Object.defineProperties(object, attributesObjects)
    参数说明：参数依次为，属性所在的对象、属性描述对象们。
   例子：
    1. var o1 = { foo:1 }; // foo 是普通方式创建的属性
	   Object.defineProperty(o1, 'bar', {}); // 给已有对象属性修改元属性。没有的属性会被创建。已有属性设置了 configurable:false 会导致失败。
	   Object.getOwnPropertyDescriptors(o1); // 注意观察普通属性元属性的默认值与 defineProperty 创建属性元属性的默认值之间的区别。
    2. var o2 = Object.defineProperties({},{ // 创建对象时定义属性的元属性
	 	 p1:{value:1},
	 	 p2:{}
	   });
    3. 

-Object.keys 与 Object.getOwnPropertyNames
 目的：返回对象非继承属性（数组形式）
 区别：keys 无法返回不可比遍历的属性；后者可以
 例子：
  Object.keys([]); // []
  Object.getOwnPropertyNames([]) // [ 'length' ]，可以用来随时查看内置对象的属性名

-控制对象状态
 目的：冻结对象的读写状态，防止对象被改变。
 用法：三种冻结方法，preventExtensions、seal 和 freeze
 例子：1. var obj = new Object(); // 这种形式等价于 var obj = {}
          Object.preventExtensions(obj); // 阻止添加新属性
		  obj.newProp = '新属性'; // 试图添加新属性
		  obj.newProp; // undefined，严格模式会报错
		  Object.isExtensible(obj); // false ，Extensible 意为可扩充
	   2. var obj2 = { oldProp: '已存在属性'};
		  Object.seal(obj2); // 既无法添加新属性，也无法删除旧属性，还设置了 configurable:false
		  delete obj2.oldProp; // 试图删除旧属性
		  obj2.oldProp; // "已存在属性"，严格模式还会报错
		  Object.isSealed(obj2); // true，注意 seal 的语义是封印，内涵否定意味。
		  // 添加属性同 preventExtensions。
		  // preventExtensions 和 seal 之后的对象，属性都还是 writable 的，可以修改属性值。
	   3. var obj3 = { oldProp: '已存在属性'};
		  Object.freeze(obj3); // 阻止增删属性及修改属性值。不可修改的实质是将 configurable 和 writable 置为 false
		  Object.isFrozen(obj3); // true

-初步认识 call()、apply()、bind() 三个 JavaScript 内置回调函数
 目的：都是通过重定义 this 指向，实现对象之间函数的“借用”。
 区别：浅显的，它们需要的参数和返回有不同。
 用法：1. obj.funObject.call(thisObject,param1,...,paramN); // 首参 thisObject 传给 funObject 里的 this 指针，余参作为 funObject 的普通参数。无返回，直接调用 funObject
	   2. obj.funObject.apply(thisObject,[param1,...,paramN]); // 首参同上，余参需要以数组形式传入。无返回，直接调用 funObject
	   3. obj.funObject.bind(thisObject,[param1,...,paramN])(); // 首参同上，余参需要以数组形式传入。返回替换了 this 的 funObject 函数。所以想执行 funObject 需要加一个“()”
 例子：暂举一个数组原型调用 call 将实例方法 join 用到字符串（类数组对象）上，实现给字符串字符间添加连接符。相当于字符串“借用了”数组原型的 join 方法。
	   1.Array.prototype.join.call('hello', '-') // "h-e-l-l-o"
	   2.Math.max.apply(null, [1,4,2,8,5,7]); 8，Math.max 原本不能计算数字数组参数中的最大数字
 想法：只有对 funObject 内部结构足够了解，才能知道怎么用 call\apply\bind

-sort() 
 目的：给数组元素排序。
 用法：无参按默认字典排序；传入函数参数，指定排序规则。
 例子：[10111, 1101, 111].sort(); // [10111, 1101, 111]
	   [10111, 1101, 111].sort((f,b)=>f-b); // [111, 1101, 10111]，函数需双参以作比较，默认不改变原数组顺序，除非满足 return 指定换位条件。（需要将逻辑转换成表达式值大于零，转换过程:递增排序 --(对立面)--> 递减 --(逻辑式)--> f>b --(算术式)--> f-b）
	   // 一句话理解排序规则函数：默认原始排序，除非满换位条件。
-map()
 目的：根据传入函数参数，对数组元素进行统一处理，返回一个新数组，不改变原数组。
 用法：map 本身可传双参，首参为函参，二参为回调对象。函参又有三个可选参数，依次为：当前元素、元素索引、数组本身
 例子：[1,2,3].map((elem,index,arr)=>{console.log('['+(arr[index]-1)+']'+elem)}) // [0]1 [1]2 [2]3
-reduce()/reduceRigeht()
 目的：根据参数对数组元素做一些与积累量相关的操作
 用法：reduce/reduceRigeht 本身可传双参，首参为函数，二参为积累量初值。函参又有四个可选参数，依次为：累计值（默认首元素起）、当前元素（默认第二元素起）、元素索引、数组本身
 例子：1. [1, 2, 3, 4, 5].reduce( (a, b) => a + b); // 15
	   2. [1, 2, 3, 4, 5].reduce( (a, b) => a + b,10); // 25
	   3. function findLongest(entries) { 
			 return entries.reduce(function (longest, entry) {
				return entry.length > longest.length ? entry : longest;
			 }, '');
		  }
          findLongest(['aaa', 'bb', 'c']) // "aaa"，找出字符数组最长元素，原则上每个元素都有 length 属性皆可用。

-骰子游戏
 // 任意范围的随机整数生成函数
 function getRandomInt(min, max) { 
	return Math.floor(Math.random() * (max - min + 1)) + min;
 }
 // 掷骰子函数
 var dice = ()=>[getRandomInt(1,6),getRandomInt(1,6),getRandomInt(1,6)];
 dice(); // 返回由3个1~6间随机整数组成的数组
					
-一种长字符串换行写的技巧：
  var ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  ALPHABET += 'abcdefghijklmnopqrstuvwxyz';
  ALPHABET += '0123456789-_';

-方便测试正则式
 function regTest(regular,string){
    var reg = regular;
    var str = string;
    function execTest(){
        r=reg.exec(str);
        console.log(String(r));
        console.log(r===null?'Not exist.':r.index);
        console.log(reg.lastIndex);
    }
    return execTest;
 }
 // 在浏览器里运行一遍即可使用

-正则表达式
 目的：正则表达式是用于匹配字符串中字符组合的模式。
 注意：在 JavaScript中，正则表达式也是对象。
 用法： 
     概括：一般通过 RegExp 的 exec 和 test 方法，以及 String 的 match、matchAll、replace、search 和 split 方法来使用。
     创建：1. var re = /foo+bar/; // 字面量方式，适用于静态使用正则式
		   2. var re = new RegExp('foo+bar'); // 适用于动态使用正则式，RegExp 也接受双参，二参表示修饰符。
 一些概念：1.括号“()”：在正则表达式中“()”常用作记忆设备。即这部分所匹配的字符将会被记住以备后续使用。又称捕获括号。
		   2.符号结核律：
						左结合符：*|+|?|$|. 与符号左边字符结合，形成词义。
						右结合符：\|^ 与符号右边字符结合，形成词义。
						可左可右：\b|\B
						二值连接：‘|’
		   3.符号分类：
					 断言（Assertions）：^|$|\b|\B|x(?=y)|x(?!y)|(?<=y)x ，表示一个匹配在某些条件下发生。断言又可划分为向前断言、向后断言和条件表达式。
		  			 字符类：区分不同类型的字符，例如区分字母和数字。
		  			 组织和范围：表示表达式字符的分组和范围。
		  			 量词（Quantifiers）：表示匹配的字符或表达式的数量。
		  			 Unicode 属性转义：基于 unicode 字符属性区分字符。
		   4.匹配子串：=》勘误：这里学得很不完整。内容属于捕获组范畴。
					 目的：正则式匹配环节及正则式的替换环节可能需要用到子字符串，分别用以构建逻辑和控制输出格式。
		  			 语法：子串写在捕获括号内。子串有有序标记，在上述两个环节各有两种标记语法，正则式中：\1、\2、...、\n；转换环节：$1、$2、...、$n。
		  			 注意：有序标记只是子串匹配结果的简单替换。参数串里的空格也将输出。
		   5.修饰符：仅举一例：/a/gimsuy.flags; // 'gimsuy'，每个字符各有含义，依次为：global、ignoreCase、multiline……
 符号详解：
		 说明：有些正则式也被纳入符号，如出“边界断言”外的“其他断言”，暂不总结，仅在例子中做尝试。
		 ‘\’，转义符，转义包含两层含义：将其后非特殊字符（字面量）转义成特殊字符；将特殊字符转移成其字面量。
		 ‘^’，行首判断符/脱字符，前者匹配输入开始（会被换行符影响，可以设置.m参消除），“[^reg]”表示与[]里面匹配规则的对立。单独“[^]”表示匹配一切字符。
		 ‘$’，匹配输入的结束，换行影响及处理同上。
		 ‘*’，匹配0或多次，等价于 {0,}。
		 ‘+’，匹配1或多次，等价于 {1,}。
		 ‘?’，匹配匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。
		 ‘.’，默认匹配除换行符之外的任何单个字符。
		 // TODO 暂时记到这里			
 例子：1.使用转义：RegExp('[a-z]\\s').test('keep think'); // true，‘\’在字符串和正则表达式中都有转义的作用，结合使用时还需进行字符串层面的转义。
	   2.理解量词：
			/no?d/.test('node'); // true
			/no?d/.test('noodles'); // false
			/no+d/.test('noodles'); // false
			/no*d/.test('hand'); // true
			/no+d/.test('hand'); // false
			// 上述量词默认贪婪模式，匹配尽可能多的量词标识字符，转换成非贪婪模式只需在量词后添加‘?’。
	   3.匹配子串：
			'foo bar barfoo'.match(/(foo) (bar) \2\1/);
	  		// 结果：['foo bar barfoo','foo','bar']，返回的是数组对象，首元素为匹配结果，后面依次为子字符串。还有其他属性暂不关注。
	  		'foooo bar bar fooo'.match(RegExp('(foo*) (bar) \\1 \\2'));
	  		// 结果：['fooo bar fooo bar','fooo','bar'],测试串里的两个"fooo"必须完全相同，印证了子串标记只是子串匹配结果的简单替代。
	  		'abcdef'.replace(/(c)(d)/,'[前文：$`][匹配串组：$&][后文：$\'][串组成员：[$1,$2]]');
	  		// 结果："ab[前文：ab][匹配串组：cd][后文：ef][串组成员：[c,d]]ef"，本例旨在说明替代参数写法及含义。
	  		'3 and 5'.replace(/[0-9]+/g,match=>2*match); // "6 and 10"，二参还可以为函数
	  		/y((..)\2)\1/.exec('yabababab') 
	  		// 结果：yabababab,abab,ab，未嵌套捕获括号时，标记次序是指“从左到右”，发生嵌套则指“由外到内”。
	   4.邮箱正则式（尝试）：/^\w+@\w+(?:\.\w+)+$/.test('123_xxx@xxx.xxx.xx') // true，尝试使用了非捕获组“(?:X)”，发现其优先级很低。
	   5.匹配标签：
			/<([\w-]+)([^>]*)>(.*?)<\/\1>/g.exec('<i class="demo">Hello</i>');
	  		// 结果：["<i class="demo">Hello</i>", "i", " class="demo"", "Hello"]
	   6.先/后行断言及其否定：
	  		'123%45%6%'.match(/\d+(?=%)/g)
	  		//?["123", "45", "6"]
	  		'123%45%6%'.match(/\d+(?!%)/g)
	  		//?["12", "4"]
	  		'123%45%6%'.match(/(?<=%)\d+/g)
	  		//?["45", "6"]
	  		'123%45%6%'.match(/(?<!%)\d+/g)
	  		//?["123", "5"]
	   
-Json 对象详解：
 概念：是一种用于数据交换的文本格式。
 目的：取代繁琐笨重的 XML 格式。
 主要特点：1.书写简单，一目了然；
		   2.符合 JavaScript 原生语法，可由解释引擎直接处理，无需解析代码。
 语法规定：（关于值的类型和格式）
	1.复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。
	2.原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。
	3.字符串必须使用双引号表示，不能使用单引号。
	4.对象的键名必须放在双引号里面。
	5.数组或对象最后一个成员的后面，不能加逗号。
 JavaScript支持：（通过原生对象 JSON 处理 JOSN 格式数据）
	1.JSON.stringify()：将一个值转为 JSON 字符串。三参，一参待转 JSON 对象；二参是数组则指定对象待转属性；是函数则用以更改返回键值；三参起修饰作用增加可读性。
	2.JSON.parse()：将 JSON 字符串转换成对应的值。双参，一参待转 JSON 字符串；二参需函数，用以更改返回键值。
 例子：1. JSON.stringify(Object.defineProperties({},{foo:{value:6,enumberable:false}})); // {}，不可遍历属性会被忽略
	   2. JSON.stringify({p1:1,p2:2,p3:3},['p1']); // "{"p1":1}"，二参对待转对象有效，数组无效；单个属性名也需使用数组。另外属性名类型是字符串，对象声明里没有引号只是简写。
	   3. try { // 通常用 try-catch 包裹转换以解析错误。
			 JSON.parse("'String'");
		  } catch(e) {
		 	 console.log('parsing error');
		  } 
		  
-'use strict' 常见规范：
	1.不能使用未声明的变量。
	2.函数里的 this 不能指向顶层对象
	3.剔除大部分删除操作。
	4.不允许变量重名:
	。。。用到再加。。。


-语法查漏补缺：
	1.JavaScript 会自动添加行末的分号，但强烈建议为代码手动加上分号。
	2.全局变量大写表示 UPPER_VAR
	3.分清楚数组操作及操作数组的函数。
		区分原则：是否改变了原数组。
		数组操作：pop|push|shift|unshift|reverse|splice|sort
		操作数组：join|concat|slice|forEach|map|filter|some|every|reduce|reduceRight|indexOf
		更多说明：某些操作数组的函数如 forEach 等能改变传入的回调对象，如果该对象是原数组，那么也就改变了原数组，但这不在区分原则考虑的范围之内。
	4.构造函数两个特点：
		1.函数体内部使用了 this 关键字，代表了所要生成的对象实例。
		2.生成对象的时候，必须使用new命令，使得构造函数执行并返回构造好的 this 对象。
		（注意：不要在构造函数内 return，这会干扰返回 this 对象，除非你知道你在干什么。） 
	 
					 

?					